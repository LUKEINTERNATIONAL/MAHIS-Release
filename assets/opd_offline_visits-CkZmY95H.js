import{S as o,m as D,y as r,aN as h,n as l,l as u}from"./index-BKKrZstI.js";const d="visits",w="unsavedVisits";class S extends o{static getOperationMode(){const e=o.getAPIStatus(),s=o.getModsStatus(),t=o.getUseIndexDBStatus();return e&&!t?"API_ONLY":e&&t?"API_WITH_INDEXDB":s&&!t?"MODS_ONLY":s&&t?"MODS_WITH_INDEXDB":"OFFLINE"}static async startVisit(e,s,t="14"){const i=this.getOperationMode();try{if(await this.getActiveVisit(e))throw new Error("Patient already has an active visit");switch(i){case"API_ONLY":return await this._handleApiOnly(e,s,t);case"API_WITH_INDEXDB":return await this._handleApiWithIndexDB(e,s,t);case"MODS_ONLY":return await this._handleModsOnly(e,s,t);case"MODS_WITH_INDEXDB":return await this._handleModsWithIndexDB(e,s,t);default:return await this._handleOffline(e,s,t)}}catch(a){throw D("Failed to start visit"),a}}static async closeVisit(e,s=new Date().toISOString()){const t=this.getOperationMode();try{if(!await this.getActiveVisit(e))throw new Error("No active visit found for patient");switch(t){case"API_ONLY":return await this._handleApiClose(e,s);case"API_WITH_INDEXDB":return await this._handleApiWithIndexDBClose(e,s);case"MODS_ONLY":return await this._handleModsClose(e,s);case"MODS_WITH_INDEXDB":return await this._handleModsWithIndexDBClose(e,s);default:return await this._handleOfflineClose(e,s)}}catch(i){throw D("Failed to close visit"),i}}static async _handleApiOnly(e,s,t){const i=await super.postJson("/visits",{patientId:String(e),startDate:new Date().toISOString(),programId:t,location_id:String(s)});return r("Visit started (API only)"),i.data}static async _handleApiClose(e,s){const t=await this.getActiveVisit(e);if(!(t!=null&&t.id))throw new Error("No active visit found");const i=await super.patchJson("/visits/".concat(t.id,"/close"),{visit:{closedDateTime:s}});return r("Visit closed (API only)"),i.data}static async _handleApiWithIndexDB(e,s,t){try{const i=await this._handleApiOnly(e,s,t);return await this._storeInIndexDB(i),i}catch(i){return console.warn("API failed, falling back to IndexDB"),this._handleOffline(e,s,t)}}static async _handleApiWithIndexDBClose(e,s){try{const t=await this._handleApiClose(e,s);return await this._updateInIndexDB(t),t}catch(t){return console.warn("API failed, falling back to IndexDB"),this._handleOfflineClose(e,s)}}static async _handleModsOnly(e,s,t){if(!await h())throw new Error("MODS connection unavailable");const a=await super.postJson("/visits",{patientId:String(e),startDate:new Date().toISOString(),programId:t,location_id:String(s)});return r("Visit started (MODS only)"),a.data}static async _handleModsClose(e,s){if(!await h())throw new Error("MODS connection unavailable");const i=await this.getActiveVisit(e);if(!(i!=null&&i.id))throw new Error("No active visit found");const a=await super.patchJson("/visits/".concat(i.id,"/close"),{visit:{closedDateTime:s}});return r("Visit closed (MODS only)"),a.data}static async _handleModsWithIndexDB(e,s,t){try{if(await h()){const a=await this._handleApiOnly(e,s,t);return await this._storeInIndexDB(a),r("Visit started (MODS + IndexDB)"),a}throw new Error("MODS connection unavailable")}catch(i){return console.warn("MODS failed, falling back to IndexDB"),this._handleOffline(e,s,t)}}static async _handleModsWithIndexDBClose(e,s){try{if(await h()){const i=await this._handleApiClose(e,s);return await this._updateInIndexDB(i),r("Visit closed (MODS + IndexDB)"),i}throw new Error("MODS connection unavailable")}catch(t){return console.warn("MODS failed, falling back to IndexDB"),this._handleOfflineClose(e,s)}}static async _handleOffline(e,s,t){const i=new Date().toISOString(),a=l(),n={patientId:e,startDate:i,closedDateTime:null,location_id:s,programId:t,sync_status:"pending",updated_at:i};return await a.postData("ADD_VISIT",{storeName:w,data:n}),r("Visit started (offline - will sync later)"),n}static async _handleOfflineClose(e,s){const t=await this.getActiveVisit(e);if(!t)throw new Error("No active visit found");const i=l(),a=t.sync_status==="pending"?w:d,n={closedDateTime:s,updated_at:new Date().toISOString(),sync_status:"pending"};return await i.postData("UPDATE_VISIT",{storeName:a,whereClause:{id:t.id},data:n}),r("Visit closed (offline - will sync later)"),{...t,...n}}static async _storeInIndexDB(e){if(!o.getUseIndexDBStatus())return;await l().postData("ADD_VISIT",{storeName:d,data:{...e,sync_status:"synced"}})}static async _updateInIndexDB(e){if(!o.getUseIndexDBStatus()||!e.id)return;await l().postData("UPDATE_VISIT",{storeName:d,whereClause:{id:e.id},data:{...e,sync_status:"synced"}})}static async getActiveVisit(e){if(this.getOperationMode().includes("API"))try{const t=await super.getJson("/check_patient_status/".concat(e));if(t!=null&&t.activeVisit)return t.activeVisit}catch(t){console.warn("Online active visit check failed, falling back to offline")}try{const t=c=>Array.isArray(c)?c:c.records||[],i=await u(w,{whereClause:{patientId:e}}),a=await u(d,{whereClause:{patientId:e}}),n=t(i),f=t(a);return[...n,...f].find(c=>!c.closedDateTime)||null}catch(t){return console.error("Failed to get active visit from offline storage:",t),null}}static async getPatientVisits(e){if(this.getOperationMode().includes("API"))try{const t=await super.getJson("/visits",{patientId:e});if(Array.isArray(t==null?void 0:t.visits))return t.visits;if(t!=null&&t.records&&Array.isArray(t.records))return t.records}catch(t){}try{const[t,i]=await Promise.all([u(w,{whereClause:{patientId:e},sortBy:"startDate",sortOrder:"desc"}),u(d,{whereClause:{patientId:e},sortBy:"startDate",sortOrder:"desc"})]);return[...t,...i].sort((a,n)=>new Date(n.startDate).getTime()-new Date(a.startDate).getTime())}catch(t){return console.error("Failed to get visits from offline storage:",t),[]}}static async syncPendingVisits(){const e=l();try{const s=await e.postData("SYNC_UNSAVED_VISITS",{});return{success:(s==null?void 0:s.success)||!1,synced:(s==null?void 0:s.syncedCount)||0,failed:(s==null?void 0:s.failedCount)||0}}catch(s){return console.error("Failed to sync pending visits:",s),{success:!1,synced:0,failed:0}}}}export{S as V};
